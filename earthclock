#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: earthclock,v 1.12 2000/02/27 23:23:21 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2000 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: eserte@cs.tu-berlin.de
# WWW:  http://user.cs.tu-berlin.de/~eserte/
#

use Tk;
use X11::Protocol;
use Getopt::Long;
use Math::Trig;

use strict;

my $pos = "fixed,53,13";
my $wait = 30*60;
my $width = 200;
my $height = 200;
my $geometry;
my $stay_on_top;
my $earthcmd = "xearth -pos %p -size %w,%h -gif > %o";
my $tmpfile = "/tmp/earth-$$.gif";
my $date;

GetOptions("pos=s" => \$pos,
	   "wait=i" => \$wait,
	   "geometry=s" => \$geometry,
	   "stayontop!" => \$stay_on_top,
	   "earthcmd=s" => \$earthcmd,
	  );

my($x,$y) = (0,0);
if (defined $geometry) {
    my(@p) = parse_geometry_string($geometry);
    if (defined $p[0] and defined $p[1]) {
	($x, $y) = @p[0, 1];
    }
    if (defined $p[2] and defined $p[3]) {
	($width, $height) = @p[2,3];
    }
}

my $top = new MainWindow;
my $id = hex($top->id);
$top->overrideredirect(1);
$top->geometry($width."x".$height."+".$x."+".$y);

my($lastx,$lasty);
my $last_earth_update;
my $img;
my $c_img;

$top->bind("<Motion>" => \&motion);
$top->bind("<ButtonPress-1>" => sub { $top->raise; });
$top->bind("<ButtonRelease-1>" => sub { undef $lastx });

my $popup_menu = $top->Menu(-tearoff => 0);
$popup_menu->command(-label => "");
my $date_entry = $popup_menu->index("last");
$popup_menu->separator;
$popup_menu->command(-label => "Force earth update",
		     -command => sub { undef $last_earth_update },
		    );
$popup_menu->checkbutton(-label => "Stay on top",
			 -variable => \$stay_on_top,
			);
$popup_menu->command(-label => "Exit",
		     -command => sub { $top->destroy },
		    );

$top->bind("<ButtonPress-3>" => sub {
	       my $e = $_[0]->XEvent;
	       $popup_menu->Post($e->X, $e->Y);
	   });

my($wrapper) = $top->wrapper;

my $x11 = new X11::Protocol;
$x11->init_extension('SHAPE') or die;

my $c = $top->Canvas(-border => 0,
		     -height => $height,
		     -width => $width,
		     -highlightthickness => 0)->pack;

my $stay_above_after;
# XXX not perfect:
$c->Tk::bind("<Visibility>" => sub {
#warn "vis";
	       if ($stay_on_top) {
		   if ($stay_above_after) {
		       $stay_above_after->cancel;
		   }
		   $stay_above_after = $c->after
		       (300, sub {
			    $top->raise;
			    #Tk->break;
			    undef $stay_above_after;
			});
	       }
 	   });

my $pixmap = $x11->new_rsrc;
$x11->CreatePixmap($pixmap, $wrapper, 1, $width, $height);
my $gc = $x11->new_rsrc;
$x11->CreateGC($gc, $pixmap, 'foreground' => $x11->white_pixel);
my $delgc = $x11->new_rsrc;
$x11->CreateGC($delgc, $pixmap, 'foreground' => $x11->black_pixel);
$x11->PolyFillRectangle($pixmap, $delgc,
			[(0, 0), $width, $height]);
$x11->PolyFillArc($pixmap, $gc, [0, 0, $width-1, $height-1, 0, 23040]);

$x11->ShapeMask($wrapper, 'Bounding', 'Set', 0, 0, $pixmap);

my $c_h = $c->createLine($width/2,$height/2,$width/2,$height/4,
			 -width=>5,-fill=>"white");
my $c_m = $c->createLine($width/2,$height/2,$width/2,0,
			 -width=>5,-fill=>"white");
my $c_s = $c->createLine($width/2,$height/2,$width/2,0,
			 -width=>3,-fill=>"white");

for my $h (0..11) {
    $c->createLine(
		   $width/2-sin(deg2rad((12-$h)*30))*$width/2,
		   $height/2-cos(deg2rad((12-$h)*30))*$height/2,
		   $width/2-sin(deg2rad((12-$h)*30))*($width/2-8),
		   $height/2-cos(deg2rad((12-$h)*30))*($height/2-8),
		   -fill => "white",
		  );
}

$top->repeat(1000, \&draw_time);
MainLoop;

sub motion{
    my $w = shift;
    my $e = $w->XEvent;
    return unless $e->s =~ /B1-/;
    if (defined $lastx) {
	my(%geom) = $x11->GetGeometry($wrapper);
	my $X = $geom{x}+$e->X-$lastx;
	my $Y = $geom{y}+$e->Y-$lasty;
	$x11->ConfigureWindow($wrapper, "x" => $X, "y" => $Y);
    }
    $lastx = $e->X;
    $lasty = $e->Y;
}

sub draw_time {
    my(@t) = localtime;
    my($h,$m,$s) = @t[2,1,0];
    $h=$h%12;
    $h+=$m/60;
    $m+=$s/60;

    if (!defined $last_earth_update ||
	$last_earth_update+$wait<time) {
	$img->delete if $img;
	my $thisearthcmd = $earthcmd;
	$thisearthcmd =~ s/%p/$pos/g;
	$thisearthcmd =~ s/%w/$width/g;
	$thisearthcmd =~ s/%h/$height/g;
	$thisearthcmd =~ s/%o/$tmpfile/g;
	system $thisearthcmd;
	if (-r $tmpfile) {
	    $img = $top->Photo(-file => $tmpfile);
	    if (!defined $c_img) {
		$c_img = $c->createImage($width/2, $height/2, -tags => "img");
		$c->lower("img");
	    }
	    $c->itemconfigure($c_img, -image => $img);
	}
	$last_earth_update=time;
    }

    if (!defined $date || $date ne scalar localtime) {
	$date = scalar localtime;
	my(@d) = localtime;
	$popup_menu->entryconfigure
	    ($date_entry,
	     -label => sprintf("%s %4d-%02d-%02d",
			       (qw(Sun Mon Tue Wed Thu Fri Sat))[$d[6]],
			       1900+$d[5], 1+$d[4], $d[3]));
    }

    $c->coords($c_h, $width/2, $height/2,
	       $width/2-sin(deg2rad((12-$h)*30))*($width/2*.6),
	       $height/2-cos(deg2rad((12-$h)*30))*($height/2*.6));
    $c->coords($c_m, $width/2, $height/2,
	       $width/2-sin(deg2rad((60-$m)*6))*($width/2*.9),
	       $height/2-cos(deg2rad((60-$m)*6))*($height/2*.9));
    $c->coords($c_s, $width/2, $height/2,
	       $width/2-sin(deg2rad((60-$s)*6))*($width/2*.9),
	       $height/2-cos(deg2rad((60-$s)*6))*($height/2*.9));
}

sub parse_geometry_string {
    my $geometry = shift;
    my @extends;
    if ($geometry =~ /([-+]?\d+)x([-+]?\d+)/) {
	$extends[2] = $1;
	$extends[3] = $2;
    }
    if ($geometry =~ /[-+](\d+)[-+](\d+)/) {
	$extends[0] = $1;
	$extends[1] = $2;
    }
    @extends;
}

END {
    unlink $tmpfile;
}

__END__
